{-         _                               _   _   _     _       _ 
  __ _  __| |_   ____ _ _ __   ___ ___  __| | | |_(_) __| | __ _| |
 / _` |/ _` \ \ / / _` | '_ \ / __/ _ \/ _` | | __| |/ _` |/ _` | |
| (_| | (_| |\ V / (_| | | | | (_|  __/ (_| | | |_| | (_| | (_| | |
 \__,_|\__,_| \_/ \__,_|_| |_|\___\___|\__,_|  \__|_|\__,_|\__,_|_|

Upgrade English Tokyo
13:00 - 17:00
17th Nov 2018
-}

-- Some extra samples I might use:
-- http://slab.org/tmp/extra-samples.zip
-- You can put them in the Dirt-Samples folder
-- (in Supercollider, File -> Open user support directory >
--  downloaded-quarks > Dirt-Samples)

{-
Topics:
1. Userbase wiki

2. Understanding syntax and type signatures

(Heavy topic)

3. Some under-documented tidal features and functions

Lets go through the examples below

4. Composing with ur

5. Orbits

For multichannel sound, taming global effects (e.g. reverb), routing patterns
to different DAW channels

6. Upcoming features in tidal 1.0.0 !!

- 6a controlling patterns with external MIDI controllers
- 6b flexible structural control
- 6c flexible tempo control (cps patterns)

7. Collaboration, e.g. through the multi-user troop editor

Please use version 0.7.5 for this:
https://github.com/Qirky/Troop/releases/tag/v0.7.5

8. Controlling MIDI synths

Requires pure-data 'vanilla'
https://puredata.info/downloads

Running this patch:
https://raw.githubusercontent.com/tidalcycles/Tidal/master/pd/midi-osc-bridge.pd

9. Feedforward

Might be tricky to get working !
https://github.com/yaxu/feedforward

10. Something else?
-}


-- ** Some (maybe) underappreciated functions **

-- * Everything is a pattern
d1 $ fast "<1 0.5>" $ sound "cp sn:2" # speed 1.5 # crush 3

-- * Compress different patterns into different parts of cycle

-- compress into the first half - from the start (0) to halfway (1/2):
d1 $ compress (0,1/2) $ sound "bd*8"
-- compress into the last quarter
d2 $ compress (3/4,1) $ sound "bd*8"

d2 $ compress (0,1/3) $ iter 4 $ n "0 .. 3" # sound "sn:3" # legato 1 # speed 1
d3 $ compress (1/3,1) $ fast "<1 0.5>" $ sound "cp:4(3,8) cp:2*2" # speed 1.5 # crush 3

-- * Repeat random values
d4 $ repeatCycles 4 $ struct "x*8?" $ sound "kicklinn"

-- * scan
d1 $ jux (rev . (0.25 <~)) $ n (scan 8) # sound "sn" # speed 2

-- * fit
-- fit has three parameters
-- a number - how far to move through the list per cycle
-- a list of values
-- a pattern of numbers
d1 $ n (fit 3 [0,1,2,3,4,5] "0 [1 3]") # sound "drum"
d2 $ n (fit 3 [0,3,4,5,6] "0 ~ 2 3") # sound "arpy"

-- More complex examples of fit
d1 $ n (fit 3 [0,2,7,24] "0 [1 0] [~ 3] 1" )
  # s "supermandolin" # legato 2 |-| n 12
  # lpf (sine * 5000 + 800)
  # lpq 0.2

d1 $ jux ((|+ n 12) . rev) $ off 0.25 ((# s "superpiano") . arpg . struct "x(3,8)")
  $ n (off (1/16) (+12) $ off 0.125 (+7) $ fit 3 [0,5,7,24] "0 [1 0] [~ 3] 1" )
  # s "supermandolin" # legato 1 |- n 12

d1 $ off 0.25 ((|+ n 24) .(# (s "supermandolin" #  gain 0.9 # legato 0.5))) $ jux rev $ n (off 0.125 (+12) $ off 0.25 (+7) $ palindrome $ fit 3 [0,2,7,12] "0 [~ 1] 1 [~ 3]") # s "supermandolin"
  # lpf (sine * 3000 + 3000)
  # lpq 0.2
  # legato 2
  |*| speed 1.5

-- * slice

-- Give it a pattern of slice numbers, an the number of slices (I will
-- probably reverse these parameters in 1.0.0!)

d1 $ loopAt 2 $ slice ("[0 1?] <2*3 3*2> <4*2> 7") 8 $ sound "arc"
  # legato 1

d3 $ jux rev $ loopAt 2 $ slice "0 <3 4*4> 2 4*8 5 2*4 4 7*2" 8 $ sound "arc" # gain 1.3
  # legato 1

-- linger

d1 $ every 4 (linger (1/2)) $ iter 4 $ n "0 .. 7" # sound "sn"
  # legato 1
  # speed 1

-- off

-- * ply

-- ply repeats each event
d1 $ ply 2 $ sound "bd ~ sn:2" # speed 2

d1 $ ply "<2 3 4>" $ sound "bd ~ sn:2" # speed 2

d1 $ every 2 (ply "<2 3 4>") $ sound "bd ~ sn:2" # speed 2

d1 $ every 4 (ply 2) $ slow 2 $ n "0 .. 7" # sound "drum"
  # legato 1
  # speed 0.5

-- * sew
-- sew takes a pattern of true/false values, and two sound patterns, e.g.:
-- t == take events from the first pattern
-- f == take events from the second pattern
d1 $ sew "t f" (sound "bd*8") (sound "cp*8")

d1 $ sew "t f" (sound "bd*8") (sound "cp*8" # speed (slow 4 $ sine + 1))

d1 $ sew (slow 2 "[t f] f")
   (sound "bd*8")
   (sound "cp*8" # speed (slow 4 $ sine + 1))

d1 $ iter 4 $ sew (iter 4 "[t f] <f [t f]>")
  (sound "bd:4*8")
  (sound "snare:4(3,8)" # speed 1.5)

-- * spaceOut
d1 $ spaceOut [1,2,0.5] $ sound "bd*2 hc:3"

-- * stripe
d1 $ jux rev $ superimpose (stripe 2) $ sound "bd mt lt ~" # speed 2

-- * superimpose
d1 $ someCycles (jux rev . (# speed 2))
  $ every 2 (superimpose (hurry 4 . rev)) $ sound "bd [sn:2 cp:4]"

-- * within

-- within applies a function within part of each cycle
d1 $ within (0,0.5) (# crush 4) $ sound "bd*4"

d1 $ within (0,0.5) (hurry 2) $ sound "bd sd:2 cp sn:3"

d1 $ within (0,0.5) (# crush 4) $ someCycles (jux rev . (# speed 2))
  $ every 2 (superimpose (hurry 4 . rev)) $ sound "bd [sn:2 cp:4]"

-- * stut

d1 $ stut 32 0.5 0.25 $ sound "bd cp:4 bd(3,8) cp:4"
  # legato 1

d1 $ stut 4 0.5 (toRational <$> sine * 0.4 + 0.04) $ sound "bd cp:4 bd(3,8) cp:4"

d1 $ jux rev $ iter 4 $ stut 16 0.5 (toRational <$> sine * 0.4 + 0.04) $ sound "bd cp:4 bd(3,8) cp:4"
  # legato 1

-- * Composing with ur

-- `ur` is for composing patterns of patterns. you tell it the number
-- of cycles the pattern will be, then give a pattern of pattern names
-- (that's stretched out over the given number of cycles, but
-- _without_ stretching out the patterns inside it), and then a list
-- of named patterns.. plus a list of named pattern transformations
-- that you can apply with.

let pats = 
      [
        ("a", stack [n "c4 c5 g4 f4 f5 g4 e5 g4" # s "superpiano" # gain "0.7",
                     n "<c3,g4,c4>" # s "superpiano"# gain "0.7"
                    ]
        ),
        ("b", stack [n "d4 c5 g4 f4 f5 g4 e5 g4" # s "superpiano" # gain "0.7",
                     n "<d3,a4,d4>" # s "superpiano"# gain "0.7"
                    ]
        ),
        ("c", stack [n "f4 c5 g4 f4 f5 g4 e5 g4" # s "superpiano" # gain "0.7",
                     n "<f4,c5,f4>" # s "superpiano"# gain "0.7"
                    ]
        )
      ]
    fx = [("rev", (# (room 0.8 # sz 0.99 # orbit 1))),
          ("faster", fast 2)
         ]
in
d1 $ ur 12 "a b c" pats fx
